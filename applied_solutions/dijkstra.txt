
---

## **Greedy Algorithms — Summary for Implementation**

### **Core Idea**

Greedy algorithms make the *locally optimal* choice at each step, hoping it leads to a *globally optimal* solution.
They’re simple to design but often require proof of correctness to ensure optimality.

---

## **Topics Covered**

1. **Dijkstra’s Algorithm** – Shortest paths in graphs with non-negative edge weights.
2. **Minimum Spanning Trees (MSTs)**

   * **Prim’s Algorithm**
   * **Kruskal’s Algorithm**

---

## **Shortest Path: Dijkstra’s Algorithm**

### **Concepts**

* **Relaxation**:
  For an edge `(u, v)` with weight `w(u, v)`:

  ```
  if dist[v] > dist[u] + w(u, v):
      dist[v] = dist[u] + w(u, v)
      pred[v] = u
  ```

  → This updates `v`'s distance if a shorter path through `u` is found.

* **Invariant:**
  Once a vertex’s shortest distance is finalized (popped from queue), it never changes.

* **Assumption:**
  Works only if **all edge weights ≥ 0** (non-negative).

---

### **Algorithm (Standard Version)**

**Input:** Graph `G(V, E)` with weights `w(u, v) ≥ 0`, source node `s`
**Output:** `dist[v]` (shortest distance from `s` to each vertex) and `pred[v]` (predecessors)

```
function Dijkstra(G, s):
    for each vertex v in V:
        dist[v] = ∞
        pred[v] = None
    dist[s] = 0
    Q = priority_queue(V, key=dist[v])   # min-heap based on distance

    while Q not empty:
        u = Q.pop_min()                  # vertex with smallest dist
        for each edge (u, v) in E:
            if dist[v] > dist[u] + w(u, v):
                dist[v] = dist[u] + w(u, v)
                pred[v] = u
                Q.decrease_key(v, dist[v])
    return dist, pred
```

---

### **Improved Practical Version (No Decrease-Key Needed)**

Since most languages’ heaps can’t decrease keys efficiently, we insert duplicates and ignore outdated ones:

```
function Dijkstra(G, s):
    for v in V:
        dist[v] = ∞
        pred[v] = None
    dist[s] = 0

    Q = priority_queue()
    Q.push((0, s))                       # (distance, node)

    while Q not empty:
        key, u = Q.pop_min()
        if key != dist[u]: continue      # ignore outdated entries
        for each edge (u, v) in E:
            if dist[v] > dist[u] + w(u, v):
                dist[v] = dist[u] + w(u, v)
                pred[v] = u
                Q.push((dist[v], v))
    return dist, pred
```

---

### **Time Complexity**

| Implementation Type | pop_min        | update   | Total Time     |
| ------------------- | -------------- | -------- | -------------- |
| Array-based         | O(V)           | O(1)     | O(V²)          |
| Min-Heap (binary)   | O(log V)       | O(log V) | O(E log V)     |
| Fibonacci Heap      | amortized O(1) | O(log V) | O(E + V log V) |

✅ For **sparse graphs** → use **min-heap** version.
✅ For **dense graphs** → array version is fine.

---

### **Proof of Correctness (Outline)**

**Induction on the set of visited vertices S:**

* Base: `dist[s] = 0` is correct.
* Inductive step: when vertex `u` with minimum `dist` is selected, all shorter paths must already be explored (since no negative edges exist).
  Therefore, `dist[u]` is final.
* Hence, all distances are correct after the algorithm finishes.

---

### **Implementation Notes**

* Must maintain:

  * `dist[]`: best known distance.
  * `pred[]`: predecessor for path reconstruction.
* Works only with **non-negative weights**.
* For out-of-date entries in heap → skip if `key > dist[u]`.
* Number of heap entries ≤ |E|, but that’s fine since `O(log|E|) ≈ O(log|V|)` asymptotically.

---

### **Summary**

| Concept                | Description                                   |
| ---------------------- | --------------------------------------------- |
| Greedy principle       | Choose next step with locally minimal cost    |
| Example                | Dijkstra’s algorithm                          |
| Data structures        | Min-priority queue (heap)                     |
| Complexity             | O(E log V) typical                            |
| Correctness depends on | Non-negative edge weights                     |
| Uses                   | Shortest paths, routing, network optimization |

---

