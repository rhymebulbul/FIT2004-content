{
  "exam": "FIT2004 - Exam 25-2",
  "part": 1,
  "questions_in_part": 5,
  "part_summary": {
    "total_marks": 15,
    "obtained": 6,
    "breakdown": [
      {"q": 1, "marks": "0/3", "topic": "Complexity Analysis"},
      {"q": 2, "marks": "3/3", "topic": "Loop Invariants"},
      {"q": 3, "marks": "1.5/3", "topic": "Graph Complexity"},
      {"q": 4, "marks": "0/3", "topic": "DP Min Operations"},
      {"q": 5, "marks": "1.5/3", "topic": "Greedy Correctness"}
    ]
  },

  "questions": [
    {
      "q_num": 1,
      "marks": 3,
      "type": "multiple_select",
      "topic": "Complexity Analysis - Recursion",
      "solution_file": "25-2_question_1_solution.md",

      "problem_statement": {
        "description": "Consider the code shown below that takes a positive integer n as input. Select all the correct options regarding the space, auxiliary space, and time complexities of this code.",
        "code": "def mystery(n):\n    if n == 0:\n        return 1\n    else:\n        return 7*mystery(n-1)+1"
      },

      "answer_options": {
        "space": ["Θ(1)", "Θ((log N)^c)", "Θ(N)", "Θ(N·(log N)^c)", "Θ(N²)"],
        "aux_space": ["Θ(1)", "Θ((log N)^c)", "Θ(N)", "Θ(N·(log N)^c)", "Θ(N²)"],
        "time": ["Θ(1)", "Θ((log N)^c)", "Θ(N)", "Θ(N·(log N)^c)", "Θ(N²)"]
      },

      "student_answer": {
        "selected": ["time_2"],
        "correct": false
      },

      "correct_answer": {
        "options": ["space_3", "aux_space_3", "time_3"],
        "brief": "Space: Θ(N) - recursion depth. Aux Space: Θ(N) - call stack. Time: Θ(N) - n recursive calls."
      },

      "grading": {
        "marks_obtained": 0,
        "feedback": "Incorrect. Selected logarithmic time complexity, but this is linear recursion."
      }
    },

    {
      "q_num": 2,
      "marks": 3,
      "type": "multiple_choice",
      "topic": "Loop Invariants - MaxHeap k-smallest",
      "solution_file": "25-2_question_2_solution.md",

      "problem_statement": {
        "description": "Given a MaxHeap-based algorithm, which loop invariant is correct?",
        "pseudocode": "function MYSTERY(A[1...n], k)\n    # Initialize MaxHeap mh with first k elements\n    i = k + 1\n    while i ≤ n do\n        if A[i] < mh.max_element() then\n            mh.pop()\n            mh.push(A[i])\n        // Loop invariant here\n        i = i + 1\n    return mh"
      },

      "answer_options": [
        "mh contains the i biggest elements of A[1...k]",
        "mh contains the k biggest elements of A[1...i+1]",
        "mh contains the i biggest elements of A[1...k+i]",
        "mh contains the k smallest elements of A[1...i]",
        "mh contains the k biggest elements of A[1...i]",
        "mh contains the i smallest elements of A[1...k]",
        "mh contains the i smallest elements of A[1...k+i]",
        "mh contains the k smallest elements of A[1...i+1]"
      ],

      "student_answer": {
        "selected": "d",
        "correct": true
      },

      "correct_answer": {
        "option": "d",
        "brief": "MaxHeap maintains k smallest elements. Root is largest of k smallest (threshold). Algorithm finds k smallest, not biggest."
      },

      "grading": {
        "marks_obtained": 3,
        "feedback": "Correct!"
      }
    },

    {
      "q_num": 3,
      "marks": 3,
      "type": "multiple_select",
      "topic": "Graph Algorithms - Complexity by Representation",
      "solution_file": "25-2_question_3_solution.md",

      "problem_statement": {
        "description": "Consider a graph G = (V, E). Select all true statements.",
        "options_summary": "Statements about adjacency matrix/list time complexities for edge check, Dijkstra, Prim, and DFS."
      },

      "answer_options": [
        "a) Adjacency matrix edge check is Θ(1)",
        "b) Sparse graph + adjacency matrix + Dijkstra = Θ(|V| log |V|)",
        "c) Sparse graph + adjacency list + Prim = Θ(|V| log |V|)",
        "d) Adjacency matrix + DFS = Θ(|V|+|E|)"
      ],

      "student_answer": {
        "selected": ["a"],
        "correct": "partial"
      },

      "correct_answer": {
        "options": ["a", "c"],
        "brief": "(a) Matrix allows O(1) edge check. (c) Prim with list on sparse graph (|E|=Θ(|V|)) is Θ(|V| log |V|). (b) False - matrix always Θ(|V|²). (d) False - matrix DFS is Θ(|V|²)."
      },

      "grading": {
        "marks_obtained": 1.5,
        "feedback": "Partial credit. Selected (a) correctly but missed (c)."
      }
    },

    {
      "q_num": 4,
      "marks": 3,
      "type": "numerical",
      "topic": "Dynamic Programming - Minimum Operations to 1",
      "solution_file": "25-2_question_4_solution.md",

      "problem_statement": {
        "description": "Given operations: subtract 1 (always), divide by 2 (if even), divide by 3 (if divisible by 3). Find MIN_OP(n) = minimum operations to go from n to 1.",
        "question": "Calculate: x = MIN_OP(10) + MIN_OP(14) + MIN_OP(15)"
      },

      "student_answer": {
        "value": "12",
        "correct": false
      },

      "correct_answer": {
        "value": "11",
        "breakdown": {
          "MIN_OP(10)": {"value": 3, "path": "10→9→3→1"},
          "MIN_OP(14)": {"value": 4, "path": "14→7→6→3→1"},
          "MIN_OP(15)": {"value": 4, "path": "15→5→4→2→1"}
        },
        "brief": "3 + 4 + 4 = 11. Use DP: MIN_OP(n) = 1 + min of available operations."
      },

      "grading": {
        "marks_obtained": 0,
        "feedback": "Incorrect. Answer was 12, correct is 11. Likely miscounted one value."
      }
    },

    {
      "q_num": 5,
      "marks": 3,
      "type": "multiple_select",
      "topic": "Greedy Algorithms - Correctness Conditions",
      "solution_file": "25-2_question_5_solution.md",

      "problem_statement": {
        "description": "Select all true statements regarding the correctness of greedy graph algorithms.",
        "options_summary": "Statements about Dijkstra, Prim, Kruskal with negative weights and/or negative cycles."
      },

      "answer_options": [
        "a) Dijkstra works for directed graphs with negative cycles",
        "b) Prim and Kruskal work for undirected graphs with negative weights (no negative cycles)",
        "c) Dijkstra works for directed graphs with negative weights (no negative cycles)",
        "d) Prim and Kruskal work for undirected graphs with negative cycles"
      ],

      "student_answer": {
        "selected": ["b"],
        "correct": "partial"
      },

      "correct_answer": {
        "options": ["b", "d"],
        "brief": "(b) MST algorithms work with negative weights. (d) MSTs are acyclic, so graph cycles (even negative) are irrelevant. (a,c) False - Dijkstra requires non-negative weights."
      },

      "grading": {
        "marks_obtained": 1.5,
        "feedback": "Partial credit. Selected (b) correctly but missed (d). MSTs are trees - cycles in graph don't matter."
      }
    }
  ]
}