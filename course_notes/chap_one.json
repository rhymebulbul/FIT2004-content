{
  "chapter": {
    "title": "Analysis of Algorithms",
    "summary": [
      "What it means to analyse an algorithm",
      "Proving correctness of an algorithm",
      "Binary search as an example",
      "Analysing time complexity",
      "Recurrence relations and asymptotic notation",
      "Analysing sorting algorithms",
      "Loop invariants",
      "Best, average, and worst-case performance"
    ],
    "sections": [
      {
        "section": "1.1 Program Verification",
        "description": "Program verification involves proving correctness and termination of algorithms.",
        "key_points": [
          "Verification requires proving correctness and termination.",
          "Binary search is used as an example for correctness proof.",
          "Loop invariants are used to establish correctness."
        ],
        "algorithm": {
          "name": "Binary Search",
          "code": [
            "function BINARY_SEARCH(array[1..n], key)",
            "  lo = 1; hi = n + 1",
            "  while lo < hi - 1:",
            "    mid = floor((lo + hi) / 2)",
            "    if key >= array[mid]: lo = mid",
            "    else: hi = mid",
            "  if array[lo] == key: return lo",
            "  else: return null"
          ],
          "invariant": {
            "description": "Maintained at every iteration if key ∈ array.",
            "rules": [
              "array[lo] ≤ key",
              "if hi ≠ n + 1 then array[hi] > key"
            ],
            "implication": "key (if exists) lies within [lo..hi)"
          }
        },
        "proof_of_correctness": {
          "steps": [
            "Initialisation: invariants hold initially when lo = 1 and hi = n + 1.",
            "Maintenance: invariants remain true after each iteration.",
            "Termination: invariants at termination imply correctness."
          ],
          "cases": {
            "key_in_array": "Algorithm finds key correctly since lo = hi - 1 implies array[lo] = key.",
            "key_not_in_array": "Algorithm terminates with null; correctness maintained."
          }
        },
        "termination_proof": {
          "theorem": "Finiteness of Binary Search",
          "statement": "If lo < hi - 1, then lo < mid < hi.",
          "conclusion": "Interval [lo..hi) decreases in size each iteration; binary search terminates."
        }
      },
      {
        "section": "1.2 Complexity Analysis",
        "description": "Analyses the time complexity of binary search using recurrence relations.",
        "recurrence_relation": {
          "formula": "T(n) = T(n/2) + a if n > 1; T(1) = b",
          "solution": "T(n) = a log2(n) + b",
          "complexity": "O(log n)"
        },
        "proof": "By induction on n.",
        "common_recurrences": {
          "logarithmic": {
            "relation": "T(n) = T(n/2) + a",
            "solution": "T(n) = a log2(n) + b"
          },
          "linear": {
            "relation": "T(n) = T(n−1) + a",
            "solution": "T(n) = a n + b"
          },
          "superlinear": {
            "relation": "T(n) = 2T(n/2) + a n",
            "solution": "T(n) = a n log(n) + b n",
            "examples": ["Mergesort"]
          },
          "quadratic": {
            "relation": "T(n) = T(n−1) + c n",
            "solution": "T(n) = (c n(n+1))/2 + b",
            "examples": ["Worst-case Quicksort"]
          },
          "exponential": {
            "relation": "T(n) = 2T(n−1) + a",
            "solution": "T(n) = (a + b) 2^n − a"
          }
        }
      },
      {
        "section": "1.3 Asymptotic Notation",
        "description": "Defines Big-O, Big-Ω, and Big-Θ notations for analysing algorithm efficiency.",
        "notations": {
          "Big-O": {
            "definition": "Upper bound on growth rate.",
            "formal": "f(n) ≤ c·g(n) for n ≥ n₀",
            "examples": ["2n+1 = O(n³)", "2n+1 = O(n)"]
          },
          "Big-Omega": {
            "definition": "Lower bound on growth rate.",
            "formal": "f(n) ≥ c·g(n) for n ≥ n₀",
            "examples": ["n⁵ = Ω(n²)", "n⁵ = Ω(n⁵)"]
          },
          "Big-Theta": {
            "definition": "Tight bound (both upper and lower).",
            "formal": "f(n) = O(g(n)) and f(n) = Ω(g(n))",
            "examples": ["n² + 3n + 5 = Θ(n²)"]
          }
        }
      },
      {
        "section": "1.4 Measures of Complexity",
        "description": "Discusses different types of complexity and algorithmic space usage.",
        "complexity_types": {
          "best_case": "Minimum instructions executed for any input.",
          "worst_case": "Maximum instructions executed for any input.",
          "average_case": "Expected instructions executed across all inputs.",
          "remark": "Course focuses on worst-case complexity."
        },
        "space_complexity": {
          "definitions": {
            "space_complexity": "Total memory used by an algorithm.",
            "auxiliary_space": "Memory excluding input storage."
          },
          "in_place_algorithm": "O(1) auxiliary space or modifies input directly."
        },
        "randomised_algorithms": {
          "expected_complexity": "Average over random decisions, not inputs.",
          "expected_worst_case": "Expected performance for the worst input.",
          "high_probability_analysis": {
            "definition": "Algorithm runs in O(f(n)) with probability ≥ 1 − 1/nᶜ.",
            "note": "Stronger than expected complexity."
          }
        }
      },
      {
        "section": "1.5 Analysis of Basic Sorting Algorithms",
        "description": "Analyses selection sort and insertion sort with correctness proofs and complexities.",
        "sorting_algorithms": [
          {
            "name": "Selection Sort",
            "key_idea": [
              "Divide array into sorted and unsorted parts.",
              "Find minimum in unsorted part, swap it into correct position."
            ],
            "algorithm": [
              "function SELECTION_SORT(array[1..n])",
              "  for i = 1 to n:",
              "    min = i",
              "    for j = i+1 to n:",
              "      if array[j] < array[min]: min = j",
              "    swap(array[i], array[min])"
            ],
            "invariant": [
              "array[1..i−1] is sorted",
              "∀x ∈ array[1..i−1], ∀y ∈ array[i..n], x ≤ y"
            ],
            "proof": {
              "initialisation": "Holds when i = 1 (empty sorted part).",
              "maintenance": "After swap, invariants preserved.",
              "termination": "At i = n, array[1..n] is sorted."
            },
            "complexity": {
              "time": {
                "best": "O(n²)",
                "average": "O(n²)",
                "worst": "O(n²)"
              },
              "space": "O(1)"
            }
          },
          {
            "name": "Insertion Sort",
            "key_idea": [
              "Maintain sorted and unsorted sublists.",
              "Insert next element into correct position in sorted sublist."
            ],
            "algorithm": [
              "function INSERTION_SORT(array[1..n])",
              "  for i = 2 to n:",
              "    key = array[i]",
              "    j = i - 1",
              "    while j > 0 and array[j] > key:",
              "      array[j + 1] = array[j]",
              "      j = j - 1",
              "    array[j + 1] = key"
            ],
            "invariant": ["array[1..i−1] is sorted"],
            "proof": {
              "initialisation": "Holds at start (empty sorted part).",
              "maintenance": "Inner loop maintains sorted order by shifting larger elements right.",
              "termination": "At i = n, array[1..n] is sorted."
            },
            "complexity": {
              "time": {
                "best": "O(n)",
                "average": "O(n²)",
                "worst": "O(n²)"
              },
              "space": "O(1)"
            }
          }
        ],
        "algorithm_properties": {
          "in_place": "Both selection and insertion sort are in-place algorithms.",
          "stability": {
            "definition": "Stable if equal elements preserve relative order.",
            "example": "Sorting names by length preserves order of equal-length names."
          }
        }
      }
    ]
  }
}
